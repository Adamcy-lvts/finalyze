import axios from 'axios';
import { computed, nextTick, onMounted, ref, watch, type Ref } from 'vue';
import { toast } from 'vue-sonner';
import { useDefenseQuestionWatcher } from '@/composables/useDefenseQuestionWatcher';
import { recordWordUsage } from '@/composables/useWordBalance';
import type { ChapterEditorProps } from '@/types/chapter-editor';

interface UseChapterDefenseDeps {
    props: ChapterEditorProps;
    chapterContent: Ref<string>;
    currentWordCount: Ref<number>;
    ensureBalance: (requiredWords: number, action: string) => boolean;
    estimates: {
        defense: () => number;
    };
}

interface DefenseQuestion {
    id: number;
    question: string;
    suggested_answer: string;
    key_points: string[];
    difficulty: 'easy' | 'medium' | 'hard';
    category: string;
    times_viewed: number;
    user_marked_helpful: boolean | null;
}

export function useChapterDefense({
    props,
    chapterContent,
    currentWordCount,
    ensureBalance,
    estimates,
}: UseChapterDefenseDeps) {
    const defenseQuestions = ref<DefenseQuestion[]>([]);
    const isLoadingDefenseQuestions = ref(false);
    const isGeneratingDefenseQuestions = ref(false);
    const lastDefenseQuestionsLoad = ref<Date | null>(null);
    const autoGenerateDefense = ref(false);

    const currentChapter = computed(() => props.chapter);

    const {
        isWatching: isWatchingForDefense,
        hasTriggeredGeneration,
        startWatching: startDefenseWatching,
        stopWatching: stopDefenseWatching,
        forceCheck: forceDefenseCheck,
        getStatusMessage: getDefenseStatusMessage,
        markGenerationTriggered,
        meetsThreshold: meetsDefenseThreshold,
        shouldShowProgressIndicator,
        progressPercentage,
        wordsRemaining,
        DEFENSE_WORD_COUNT_THRESHOLD,
    } = useDefenseQuestionWatcher(
        props.project,
        props.chapter,
        chapterContent,
        async () => {
            await generateNewDefenseQuestions();
        }
    );

    const getDefenseAutoPreferenceKey = (projectId: number, chapterNumber: number) =>
        `defense_auto_generate_${projectId}_ch_${chapterNumber}`;

    const loadDefenseAutoPreference = () => {
        try {
            const stored = localStorage.getItem(
                getDefenseAutoPreferenceKey(props.project.id, props.chapter.chapter_number)
            );
            return stored === 'true';
        } catch (error) {
            console.warn('Failed to load defense auto-generation preference:', error);
            return false;
        }
    };

    const saveDefenseAutoPreference = (value: boolean) => {
        try {
            localStorage.setItem(
                getDefenseAutoPreferenceKey(props.project.id, props.chapter.chapter_number),
                String(value)
            );
        } catch (error) {
            console.warn('Failed to save defense auto-generation preference:', error);
        }
    };

    autoGenerateDefense.value = loadDefenseAutoPreference();

    const shouldLoadDefenseQuestions = () => {
        if (!defenseQuestions.value.length) return true;
        if (!lastDefenseQuestionsLoad.value) return true;

        const sixHoursAgo = new Date(Date.now() - 6 * 60 * 60 * 1000);
        return lastDefenseQuestionsLoad.value < sixHoursAgo;
    };

    const loadDefenseQuestions = async (forceRefresh = false, options: { skipGeneration?: boolean } = {}) => {
        if (isLoadingDefenseQuestions.value) return;

        const skipGeneration = options.skipGeneration ?? true;

        isLoadingDefenseQuestions.value = true;
        try {
            console.log('Loading defense questions with params:', {
                project_id: props.project.id,
                chapter_number: currentChapter.value?.chapter_number,
                limit: 5,
                force_refresh: forceRefresh,
                skip_generation: skipGeneration,
            });

            const response = await axios.get(`/api/projects/${props.project.id}/defense/questions`, {
                params: {
                    chapter_number: currentChapter.value?.chapter_number || null,
                    limit: 5,
                    force_refresh: forceRefresh ? 1 : 0,
                    skip_generation: skipGeneration ? 1 : 0,
                },
                headers: {
                    Accept: 'application/json',
                    'X-Requested-With': 'XMLHttpRequest',
                },
            });

            console.log('Defense questions loaded:', response.data);

            defenseQuestions.value = response.data.questions || [];
            lastDefenseQuestionsLoad.value = new Date();

            if (response.data.questions && response.data.questions.length > 0) {
                const chapterCacheKey = `defense_questions_${props.project.id}_chapter_${currentChapter.value?.chapter_number}`;
                localStorage.setItem(
                    chapterCacheKey,
                    JSON.stringify({
                        questions: response.data.questions,
                        chapter_number: currentChapter.value?.chapter_number,
                        loaded_at: new Date().toISOString(),
                    })
                );
            } else if (!forceRefresh) {
                console.log('No existing questions found for this chapter');
                console.log(`Current word count: ${currentWordCount.value}/${DEFENSE_WORD_COUNT_THRESHOLD}`);
                console.log('User must click "Generate Questions" button to create defense questions');
            }
        } catch (error: any) {
            console.error('Failed to load defense questions:', error);

            if (error.response) {
                console.error('Response status:', error.response.status);
                console.error('Response data:', error.response.data);

                if (error.response.status === 422) {
                    const firstError = Object.values(error.response.data.errors || {})[0];
                    if (firstError && Array.isArray(firstError)) {
                        toast.error(`Validation Error: ${firstError[0]}`);
                    } else {
                        toast.error('Invalid request parameters. Please refresh the page.');
                    }
                } else if (error.response.status === 500) {
                    toast.error('Server error. Please try again later.');
                } else {
                    toast.error('Failed to load defense questions');
                }
            } else if (error.request) {
                console.error('No response received:', error.request);
                toast.error('Network error. Please check your connection.');
            } else {
                console.error('Error setting up request:', error.message);
                toast.error('An unexpected error occurred');
            }

            defenseQuestions.value = [];
        } finally {
            isLoadingDefenseQuestions.value = false;
        }
    };

    const countWords = (text: string) =>
        text
            ? text
                  .replace(/<[^>]*>/g, ' ')
                  .trim()
                  .split(/\s+/)
                  .filter(word => word.length > 0).length
            : 0;

    const generateNewDefenseQuestions = async (options: { autoTriggered?: boolean } = {}) => {
        if (isGeneratingDefenseQuestions.value) return;

        const autoTriggered = options.autoTriggered ?? false;
        const requiredWords = estimates.defense();
        if (!ensureBalance(requiredWords, 'generate defense questions')) {
            return;
        }

        isGeneratingDefenseQuestions.value = true;

        try {
            const response = await axios.post(
                `/api/projects/${props.project.id}/defense/questions/generate`,
                {
                    chapter_number: currentChapter.value.chapter_number,
                },
                {
                    headers: {
                        'X-CSRF-TOKEN':
                            document.querySelector('meta[name="csrf-token"]')?.getAttribute('content'),
                        Accept: 'application/json',
                        'Content-Type': 'application/json',
                    },
                }
            );

            if (response.data && response.data.questions) {
                defenseQuestions.value = response.data.questions;
                lastDefenseQuestionsLoad.value = new Date();

                const generatedWordCount = response.data.questions.reduce((total: number, q: DefenseQuestion) => {
                    const questionWords = countWords(q.question);
                    const answerWords = countWords(q.suggested_answer);
                    const keyPointWords = (q.key_points || []).reduce((sum, point) => sum + countWords(point), 0);
                    return total + questionWords + answerWords + keyPointWords;
                }, 0);

                const chapterCacheKey = `defense_questions_${props.project.id}_chapter_${currentChapter.value?.chapter_number}`;
                localStorage.setItem(
                    chapterCacheKey,
                    JSON.stringify({
                        questions: response.data.questions,
                        chapter_number: currentChapter.value?.chapter_number,
                        loaded_at: new Date().toISOString(),
                    })
                );

                toast.success(`Generated ${response.data.questions.length} new questions`);

                recordWordUsage(
                    generatedWordCount || estimates.defense(),
                    'Defense questions',
                    'chapter',
                    props.chapter.id
                ).catch(err => console.error('Failed to record word usage (defense):', err));

                hasTriggeredGeneration.value = true;
                markGenerationTriggered();

                if (autoTriggered) {
                    console.log('Auto-generated defense questions after meeting threshold.');
                }
            }
        } catch (error) {
            console.error('Failed to generate defense questions:', error);
            toast.error('Failed to generate defense questions');
        } finally {
            isGeneratingDefenseQuestions.value = false;
        }
    };

    const attemptAutoGenerateDefense = async () => {
        if (
            !autoGenerateDefense.value ||
            isGeneratingDefenseQuestions.value ||
            isLoadingDefenseQuestions.value ||
            hasTriggeredGeneration.value ||
            !meetsDefenseThreshold.value ||
            defenseQuestions.value.length > 0
        ) {
            return;
        }

        await generateNewDefenseQuestions({ autoTriggered: true });
    };

    const handleDefenseAutoToggle = (enabled: boolean) => {
        autoGenerateDefense.value = enabled;
        saveDefenseAutoPreference(enabled);

        if (enabled) {
            attemptAutoGenerateDefense();
        }
    };

    const markQuestionHelpful = async (questionId: number, helpful: boolean) => {
        try {
            await axios.patch(
                `/api/projects/${props.project.id}/defense/questions/${questionId}`,
                {
                    user_marked_helpful: helpful,
                },
                {
                    headers: {
                        'X-CSRF-TOKEN':
                            document.querySelector('meta[name="csrf-token"]')?.getAttribute('content'),
                        Accept: 'application/json',
                        'Content-Type': 'application/json',
                    },
                }
            );

            const question = defenseQuestions.value.find(q => q.id === questionId);
            if (question) {
                question.user_marked_helpful = helpful;
            }

            toast.success(helpful ? 'Question marked as helpful' : 'Removed helpful mark');
        } catch (error) {
            console.error('Failed to mark question:', error);
            toast.error('Failed to update question');
        }
    };

    const hideQuestion = async (questionId: number) => {
        try {
            await axios.delete(`/api/projects/${props.project.id}/defense/questions/${questionId}`, {
                headers: {
                    'X-CSRF-TOKEN':
                        document.querySelector('meta[name="csrf-token"]')?.getAttribute('content'),
                    Accept: 'application/json',
                },
            });

            defenseQuestions.value = defenseQuestions.value.filter(q => q.id !== questionId);

            localStorage.setItem(
                `defense_questions_${props.project.id}`,
                JSON.stringify({
                    questions: defenseQuestions.value,
                    loaded_at: new Date().toISOString(),
                })
            );

            toast.success('Question hidden');
        } catch (error) {
            console.error('Failed to hide question:', error);
            toast.error('Failed to hide question');
        }
    };

    const loadFromCache = async () => {
        const chapterCacheKey = `defense_questions_${props.project.id}_chapter_${currentChapter.value?.chapter_number}`;
        const cached = localStorage.getItem(chapterCacheKey);
        let shouldLoadFresh = true;

        if (cached) {
            const parsed = JSON.parse(cached);
            const loadedAt = new Date(parsed.loaded_at);
            const sixHoursAgo = new Date(Date.now() - 6 * 60 * 60 * 1000);

            if (loadedAt > sixHoursAgo && parsed.chapter_number === currentChapter.value?.chapter_number) {
                defenseQuestions.value = parsed.questions;
                lastDefenseQuestionsLoad.value = loadedAt;
                shouldLoadFresh = false;
            }
        }

        if (shouldLoadFresh) {
            await loadDefenseQuestions(false, { skipGeneration: true });
        }
    };

    watch(
        () => props.chapter,
        async () => {
            defenseQuestions.value = [];
            stopDefenseWatching();
            startDefenseWatching();
            autoGenerateDefense.value = loadDefenseAutoPreference();
            await loadDefenseQuestions(false, { skipGeneration: true });
            await nextTick(() => {
                forceDefenseCheck();
                attemptAutoGenerateDefense();
            });
        },
        { immediate: false }
    );

    watch([currentWordCount, autoGenerateDefense], () => {
        attemptAutoGenerateDefense();
    });

    onMounted(async () => {
        await loadFromCache();
        startDefenseWatching();
        await nextTick(() => {
            forceDefenseCheck();
            attemptAutoGenerateDefense();
        });
    });

    return {
        defenseQuestions,
        isLoadingDefenseQuestions,
        isGeneratingDefenseQuestions,
        autoGenerateDefense,
        shouldLoadDefenseQuestions,
        loadDefenseQuestions,
        generateNewDefenseQuestions,
        markQuestionHelpful,
        hideQuestion,
        handleDefenseAutoToggle,
        attemptAutoGenerateDefense,
        getDefenseStatusMessage,
        shouldShowDefenseProgress: shouldShowProgressIndicator,
        defenseProgressPercentage: progressPercentage,
        defenseWordsRemaining: wordsRemaining,
        hasTriggeredGeneration,
        meetsDefenseThreshold,
    };
}
