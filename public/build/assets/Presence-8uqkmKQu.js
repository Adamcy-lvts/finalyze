import{N as w,ag as T,b as f,e as E,t as y,q as S,T as I,d as x,P as O,L as P,_ as b}from"./app-DI0P-SCf.js";import{r as U}from"./index-BNCR1WzN.js";import{d as j,b as $}from"./useForwardExpose-DExeGtxo.js";import{e as D}from"./index-DF4e6W7v.js";function _(t,e){const s=typeof t=="string"&&!e?`${t}Context`:e,o=Symbol(s);return[i=>{const r=w(o,i);if(r||r===null)return r;throw new Error(`Injection \`${o.toString()}\` not found. Component must be used within ${Array.isArray(t)?`one of the following components: ${t.join(", ")}`:`\`${t}\``}`)},i=>(T(o,i),i)]}const[L,Y]=_("ConfigProvider");function z(t){const e=L({dir:f("ltr")});return E(()=>t?.value||e.dir?.value||"ltr")}function F(t,e){const s=f(t);function o(c){return e[s.value][c]??s.value}return{state:s,dispatch:c=>{s.value=o(c)}}}function R(t,e){const s=f({}),o=f("none"),v=f(t),c=t.value?"mounted":"unmounted";let i;const r=e.value?.ownerDocument.defaultView??j,{state:m,dispatch:u}=F(c,{mounted:{UNMOUNT:"unmounted",ANIMATION_OUT:"unmountSuspended"},unmountSuspended:{MOUNT:"mounted",ANIMATION_END:"unmounted"},unmounted:{MOUNT:"mounted"}}),a=n=>{if(D){const l=new CustomEvent(n,{bubbles:!1,cancelable:!1});e.value?.dispatchEvent(l)}};y(t,async(n,l)=>{const A=l!==n;if(await S(),A){const N=o.value,d=h(e.value);n?(u("MOUNT"),a("enter"),d==="none"&&a("after-enter")):d==="none"||d==="undefined"||s.value?.display==="none"?(u("UNMOUNT"),a("leave"),a("after-leave")):l&&N!==d?(u("ANIMATION_OUT"),a("leave")):(u("UNMOUNT"),a("after-leave"))}},{immediate:!0});const p=n=>{const l=h(e.value),A=l.includes(CSS.escape(n.animationName)),N=m.value==="mounted"?"enter":"leave";if(n.target===e.value&&A&&(a(`after-${N}`),u("ANIMATION_END"),!v.value)){const d=e.value.style.animationFillMode;e.value.style.animationFillMode="forwards",i=r?.setTimeout(()=>{e.value?.style.animationFillMode==="forwards"&&(e.value.style.animationFillMode=d)})}n.target===e.value&&l==="none"&&u("ANIMATION_END")},g=n=>{n.target===e.value&&(o.value=h(e.value))},M=y(e,(n,l)=>{n?(s.value=getComputedStyle(n),n.addEventListener("animationstart",g),n.addEventListener("animationcancel",p),n.addEventListener("animationend",p)):(u("ANIMATION_END"),i!==void 0&&r?.clearTimeout(i),l?.removeEventListener("animationstart",g),l?.removeEventListener("animationcancel",p),l?.removeEventListener("animationend",p))},{immediate:!0}),C=y(m,()=>{const n=h(e.value);o.value=m.value==="mounted"?n:"none"});return I(()=>{M(),C()}),{isPresent:E(()=>["mounted","unmountSuspended"].includes(m.value))}}function h(t){return t&&getComputedStyle(t).animationName||"none"}var G=x({name:"Presence",props:{present:{type:Boolean,required:!0},forceMount:{type:Boolean}},slots:{},setup(t,{slots:e,expose:s}){const{present:o,forceMount:v}=O(t),c=f(),{isPresent:i}=R(o,c);s({present:i});let r=e.default({present:i.value});r=U(r||[]);const m=P();if(r&&r?.length>1){const u=m?.parent?.type.name?`<${m.parent.type.name} />`:"component";throw new Error([`Detected an invalid children for \`${u}\` for  \`Presence\` component.`,"","Note: Presence works similarly to `v-if` directly, but it waits for animation/transition to finished before unmounting. So it expect only one direct child of valid VNode type.","You can apply a few solutions:",["Provide a single child element so that `presence` directive attach correctly.","Ensure the first child is an actual element instead of a raw text node or comment node."].map(a=>`  - ${a}`).join(`
`)].join(`
`))}return()=>v.value||o.value||i.value?b(e.default({present:i.value})[0],{ref:u=>{const a=$(u);return typeof a?.hasAttribute>"u"||(a?.hasAttribute("data-reka-popper-content-wrapper")?c.value=a.firstElementChild:c.value=a),a}}):null}});export{G as P,F as a,_ as c,L as i,z as u};
