import{R as I,c1 as O,r as v,p as y,H as N,cu as T,cv as P,V as S,cw as b,I as w,z as x,L as $,d as j,W as U,aw as R}from"./vendor-Bd-YbXdQ.js";import{r as _}from"./index-DhgXNBxs.js";import{f as D,a as F}from"./useForwardExpose-BQPhk1XK.js";import{a as k}from"./index-CPshGmzU.js";function L(t,e){const a=typeof t=="string"&&!e?`${t}Context`:e,o=Symbol(a);return[n=>{const r=I(o,n);if(r||r===null)return r;throw new Error(`Injection \`${o.toString()}\` not found. Component must be used within ${Array.isArray(t)?`one of the following components: ${t.join(", ")}`:`\`${t}\``}`)},n=>(O(o,n),n)]}function X(){let t=document.activeElement;if(t==null)return null;for(;t!=null&&t.shadowRoot!=null&&t.shadowRoot.activeElement!=null;)t=t.shadowRoot.activeElement;return t}const[W,Z]=L("ConfigProvider");function ee(t){const e=W({dir:v("ltr")});return y(()=>t?.value||e.dir?.value||"ltr")}function V(t){const e=N(),a=e?.type.emits,o={};return a?.length||console.warn(`No emitted event found. Please check component: ${e?.type.__name}`),a?.forEach(c=>{o[T(P(c))]=(...i)=>t(c,...i)}),o}function z(t){const e=N(),a=Object.keys(e?.type.props??{}).reduce((c,i)=>{const n=(e?.type.props[i]).default;return n!==void 0&&(c[i]=n),c},{}),o=S(t);return y(()=>{const c={},i=e?.vnode.props??{};return Object.keys(i).forEach(n=>{c[P(n)]=i[n]}),Object.keys({...a,...c}).reduce((n,r)=>(o.value[r]!==void 0&&(n[r]=o.value[r]),n),{})})}function te(t,e){const a=z(t),o=e?V(e):{};return y(()=>({...a.value,...o}))}function ne(t,e="reka"){return`${e}-${b?.()}`}function B(t,e){const a=v(t);function o(i){return e[a.value][i]??a.value}return{state:a,dispatch:i=>{a.value=o(i)}}}function H(t,e){const a=v({}),o=v("none"),c=v(t),i=t.value?"mounted":"unmounted";let n;const r=e.value?.ownerDocument.defaultView??D,{state:d,dispatch:l}=B(i,{mounted:{UNMOUNT:"unmounted",ANIMATION_OUT:"unmountSuspended"},unmountSuspended:{MOUNT:"mounted",ANIMATION_END:"unmounted"},unmounted:{MOUNT:"mounted"}}),u=s=>{if(k){const m=new CustomEvent(s,{bubbles:!1,cancelable:!1});e.value?.dispatchEvent(m)}};w(t,async(s,m)=>{const A=m!==s;if(await $(),A){const E=o.value,f=h(e.value);s?(l("MOUNT"),u("enter"),f==="none"&&u("after-enter")):f==="none"||f==="undefined"||a.value?.display==="none"?(l("UNMOUNT"),u("leave"),u("after-leave")):m&&E!==f?(l("ANIMATION_OUT"),u("leave")):(l("UNMOUNT"),u("after-leave"))}},{immediate:!0});const p=s=>{const m=h(e.value),A=m.includes(CSS.escape(s.animationName)),E=d.value==="mounted"?"enter":"leave";if(s.target===e.value&&A&&(u(`after-${E}`),l("ANIMATION_END"),!c.value)){const f=e.value.style.animationFillMode;e.value.style.animationFillMode="forwards",n=r?.setTimeout(()=>{e.value?.style.animationFillMode==="forwards"&&(e.value.style.animationFillMode=f)})}s.target===e.value&&m==="none"&&l("ANIMATION_END")},g=s=>{s.target===e.value&&(o.value=h(e.value))},M=w(e,(s,m)=>{s?(a.value=getComputedStyle(s),s.addEventListener("animationstart",g),s.addEventListener("animationcancel",p),s.addEventListener("animationend",p)):(l("ANIMATION_END"),n!==void 0&&r?.clearTimeout(n),m?.removeEventListener("animationstart",g),m?.removeEventListener("animationcancel",p),m?.removeEventListener("animationend",p))},{immediate:!0}),C=w(d,()=>{const s=h(e.value);o.value=d.value==="mounted"?s:"none"});return x(()=>{M(),C()}),{isPresent:y(()=>["mounted","unmountSuspended"].includes(d.value))}}function h(t){return t&&getComputedStyle(t).animationName||"none"}var oe=j({name:"Presence",props:{present:{type:Boolean,required:!0},forceMount:{type:Boolean}},slots:{},setup(t,{slots:e,expose:a}){const{present:o,forceMount:c}=U(t),i=v(),{isPresent:n}=H(o,i);a({present:n});let r=e.default({present:n.value});r=_(r||[]);const d=N();if(r&&r?.length>1){const l=d?.parent?.type.name?`<${d.parent.type.name} />`:"component";throw new Error([`Detected an invalid children for \`${l}\` for  \`Presence\` component.`,"","Note: Presence works similarly to `v-if` directly, but it waits for animation/transition to finished before unmounting. So it expect only one direct child of valid VNode type.","You can apply a few solutions:",["Provide a single child element so that `presence` directive attach correctly.","Ensure the first child is an actual element instead of a raw text node or comment node."].map(u=>`  - ${u}`).join(`
`)].join(`
`))}return()=>c.value||o.value||n.value?R(e.default({present:n.value})[0],{ref:l=>{const u=F(l);return typeof u?.hasAttribute>"u"||(u?.hasAttribute("data-reka-popper-content-wrapper")?i.value=u.firstElementChild:i.value=u),u}}):null}});export{oe as P,ne as a,te as b,L as c,ee as d,B as e,V as f,X as g,W as i,z as u};
